//Microservice Design Pattern
	
	1. Aggregate Design Pattern
		Individual users have multiple accounts in multiple services a data pump(kafka queue) is 
		used to send that data to services-owned microservice db to hold the aggregate pattern.
	
	2. API-Gateway design pattern
	
	3. Chain of responsibility design pattern
	
	4. Asynchronous messaging
	
	5. Database
		->Shared Database (When converted from monolith)
		->Database Per Service
		
	6. Branch Pattern 
		simultaneous process the request and response from multiple microservices
		
	7. Circuit Breaker
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	// Coding Design Pattern
	
	1. Aggregate root (when we dont expose the constructor and let all insertion done by custom method(root object))
		//User 1
		Phone phone = new Phone(9781753093);
		
		//User 2
		Phone phone = new Phone(9781753093);
		
		//Now both user have same phone number which is not acceptable.
		
		Solution:
		class Phone{
			private long number;
			
			private void Phone(long number){
				this.number = number; 
			}
			
			public void addPhone(long number){
				if(!UserDAO.findByPhnNumber(number).isPresent()){
					new phone(number);
				}
				throw new Exception("Phone Number already present");
			}
		}
		
	2. Iterator Pattern (It provides a way to access the element in a aggregate object)
		//User
		public class User {
			private String userName;
			private String Company;
			private long phoneNumber;
			private static List<User> users;

			private User(String userName, String company, long phoneNumber) {
				this.userName = userName;
				Company = company;
				this.phoneNumber = phoneNumber;
			}

			public static void addUser(String userName, String company, long phoneNumber){
				if(users == null){
					users = new ArrayList<>();
				}
			   users.add(new User(userName, company, phoneNumber));
			}

			public static CustomIterator<User> iterate(){
				return new CustomIterator(users);
			}
		}
		
		//CustomIterator
		public class CustomIterator<E> implements Iterator {
			private List<E> list;
			int count;

			public CustomIterator(List<E> e) {
				list = e;
			}

			@Override
			public boolean hasNext() {
				if(count<list.size()){
					return true;
				}
				return false;
			}

			@Override
			public E next() {
				E e = list.get(count);
				count++;
				return e;
			}

			@Override
			public void remove(){
				System.out.println("Not Supported");
			}
		}
		
		//Main
		public static void main(String[] args) {
			User.addUser("Chinmoy","Persistent",978175);
			User.addUser("Chinmoy","Persistent",978175);

			CustomIterator<User> ci = User.iterate();

			while(ci.hasNext()){
				System.out.println(ci.next());
				ci.remove();
			}
		}
	
	3. Adapter Pattern (It helps to make two incompatible classes compatible)
	
		public interface IReport{
			public void export();
		}
		
		public class AdapterPdf implements IReport{
			@Override
			public void export(){
				ThirdPartyPdf x = new ThirdPartyPdf();
				x.save();
			}
		}
		
		public class ExcelReport implements IReport{
			@Override
			public void export(){
				export();
			}
		}
		
		//Main
		IReport pdf = new AdapterPdf();
		IReport excel = new AdapterPdf();
		
	4. Template Pattern (Define the skeleton of an algorithm in an operation deferring some steps to client subclasses.)
		//Using abstract class in java
	
	5. Bridge Pattern
		The Bridge design pattern allows you to separate the abstraction from the implementation.It is a structural design pattern.
		There are 2 parts in Bridge design pattern :
			1.Abstraction
			2.Implementation
			
		This is a design mechanism that encapsulates an implementation class inside of an interface class.

			The bridge pattern allows the Abstraction and the Implementation to be developed independently and the client code can access only the Abstraction part without being concerned about the Implementation part.
			The abstraction is an interface or abstract class and the implementor is also an interface or abstract class.
			The abstraction contains a reference to the implementor. Children of the abstraction are referred to as refined abstractions, and children of the implementor are concrete implementors. Since we can change the reference to the implementor in the abstraction, we are able to change the abstraction’s implementor at run-time. Changes to the implementor do not affect client code.
			It increases the loose coupling between class abstraction and it’s implementation.
			
			->without bridge design pattern
			
										vehicle
				  _________________________|____________________________
				 |														|		
				Bus	                                                   Car
		_________|_________									   _________|_________
	   |                   |                                  |                   |
   ProduceBus          AssembleBus						ProduceCar			 AssembleCar
   
			->with bridge design pattern
							
				  ______________________________________________________
				 |														|		
			  Vehicle                                                Workshop
		_________|_________									   _________|_________
	   |                   |                                  |                   |
	  Bus 		          Car						    	Produce 			Assemble